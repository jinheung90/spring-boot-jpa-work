
# jinheung-project



### jinheung-api-gateway

```
     spring server port : 8081
     
     기능 : 글로벌 인증 필터 
     헤더에 파싱된 유저아이디, 유저롤을 넣어줍니다
```

### jinheung-euraka-server

```
    기능 : 유레카 서버 해당 서비스 목록을 확인할 수 있다
```

### jinheung-user-profile 

```
    spring server port : 8082
    기능 : 유저의 정보, jwt 토큰 발행 및 파싱
```
#### api 목록
| httpMethod | path | description
|:-----------|:---|:---|
| GET        | /user/token/verify | 유저 정보 파싱해서 가져오기 



### client-proxy 

```
    spring server port : 8083
    
    기능: kafka에서 보낸 여러 이벤트 들을 받아서 websocket으로 
    유저에게 전달 (ex 재고가 부족해요!, 잔액이 부족해요!)
```



### jinheung-shop

```
    shop main 8084
    기능 : 아임포트 결제 pay verify, 장바구니 

    shop product 8085
    기능 : 재고를 차감하는 서비스
    재고가 없으면 메세지를 날린다
    재고의 수를 shop search와 동기화 시킨다 
    
    shop search 8086
    기능 : es를 이용한 제품 검색 
```
## 설계도 
![](설계도.png)
### 결제
![](결제.png)


### redis-test 
```
    - sns 좋아요 기능
    - 하게된 이유
        - 처음에 생각했던것은 좋아요 기능 같은경우 클릭했다가 지웠다가 이런것을 막 누르지 않을까? 
        그러면 트래픽 문제가 생기지 않을까? 였습니다 그리고 나서 레디스를 써봐야겠다라는 
        생각으로 도입을 준비하게 되었습니다
    - 테스트 과정
        - 삽입 20000개 (not bulk) ,메모리 16, redis 6.0, mysql 8.0
    - 테스트 결과
        redis : 19.x  
        mysql : 34.x
        - 일반 노트북으로 테스트를 해봤고 삽입만 했을 때 속도가 거의 두 배나 차이나는 것을 보고 
        아 이렇게 하고 주기적으로 동기화 코드 작성하면 훨씬 더 속도가 빠르겠구나 라는 생각을 했습니다
    - 그렇게 실제로 도입했지만 없애게 되었는데 이것은 개발 초기에 하는 것이 아니라 
    나중에 사용자가 많아졌을 때 해야하는 작업임을 깨달은겁니다 실제로 elasticache를 올렸기에 돈이깨졌고 
    동기화 작업 코드도 만들어야했습니다 그리고 나서 결국 1달정도 됬을 때 없앴습니다 
    낭비되는 작업을 했기 때문입니다 나중에는 꼭 이러한 작업을 더 많이 해보고 싶습니다.
    
    그리고 처음에 걱정했던 부분은 싱글스레드여서 쓰기 업데이트 할 때 속도가 느려지지 않을까? 라는 생각을 가지고 있었는데 
    애초에 차이가 많이 났었어서 괜찮았던 것 같습니다 
```